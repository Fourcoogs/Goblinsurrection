#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 8.0
#  in conjunction with Tcl version 8.6
#    Nov 09, 2024 05:01:03 PM CST  platform: Windows NT
#    Nov 10, 2024 04:07:45 PM CST  platform: Windows NT
#    Nov 10, 2024 04:09:20 PM CST  platform: Windows NT
#    Nov 10, 2024 04:21:24 PM CST  platform: Windows NT
#    Nov 24, 2024 04:31:02 PM CST  platform: Windows NT
#    Nov 24, 2024 04:41:43 PM CST  platform: Windows NT
#    Nov 28, 2024 11:29:15 AM CST  platform: Windows NT
#    Nov 28, 2024 11:35:13 AM CST  platform: Windows NT
#    Nov 28, 2024 08:41:10 PM CST  platform: Windows NT
#    Nov 29, 2024 03:43:36 PM CST  platform: Windows NT
#    Nov 29, 2024 04:07:13 PM CST  platform: Windows NT
#    Nov 30, 2024 05:24:56 PM CST  platform: Windows NT

import sys
import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *
import characterCreator as cc
from character import *
from combat import *
# import traits
import equipment
from dice import Dice
import time

import gui

_debug = True # False to eliminate debug printing from callback functions.

class GameLoop:
    def __init__(self, loadFile=None):
        self.places = {"Byzend":GameLoop.Byzend(), "Gorkhen":GameLoop.Gorkhen(), "Ushnakh":GameLoop.Ushnakh(), 
                       "Darkhour":GameLoop.Darkhour(), "Elden":GameLoop.Elden(), "Hevok":GameLoop.Hevok(), 
                       "Centria":GameLoop.Centria(), "Media":GameLoop.Media(), "Graygold":GameLoop.Graygold(), 
                       "Highland":GameLoop.Highland(), "Dirennia":GameLoop.Dirennia(), "Merwendel":GameLoop.Merwendel(), 
                       "Faewind":GameLoop.Faewind(), "Hobbiton":GameLoop.Hobbiton()}
        self.places["Elden Fields"] = self.places["Elden"]
        if loadFile != None:
            pass
        else:
            self.funds = 1000
            self.heat = 0
            self.stability = 100
            self.agents = []
            self.itempool = []
    def setPlayer(self, player):
        self.player = player
        return
    def starting_team(self, teamlist):
        self.agents.extend(teamlist)
        # self.agents.append(self.player)
        return self.agents
    def start_Game(self, location):
        for i in self.agents:
            i.location = location
        self.turn = 1
        self.standby = self.agents.copy()
        self.eventQueue = []
        self.itempool = []
        self.dead = []
        return
    def pack_up(self, location):
        self.player.location = location
        for i in self.agents:
            i.location = location
        _w1.current_location.configure(text = player.location.name)
    def swapEquip(self, char, item, type):
        theEquipment = {}
        for i in self.itempool:
            if i.name == item:
                theEquipment[type] = i
                self.itempool.remove(i)
                break
        else:
            theEquipment[type] = equipment.Empty()
        for j in self.agents:
            if j.nickname == char:
                self.itempool.extend(j.setEquip(theEquipment))
                break
        for k in self.itempool:
            if k.name == "empty":
                self.itempool.remove(k)
    def queueEvent(self, type, target):
        match type:
            case "Assassination":
                for i in self.player.location.nobles:
                    if i.nickname == target:
                        theGuy = i
                target = theGuy
                self.eventQueue.append(self.Assassinate(self.player.location, self.agents, target, self))
            case "Recruitment":
                self.eventQueue.append(self.Recruit(self.player.location, self.agents, None, self))
            case "Buy Equipment":
                self.eventQueue.append(self.BuyGear(self.player.location, self.agents, None, self))
            case "Change Location":
                target = self.getRegion(target)
                self.eventQueue.append(self.Pack_up(target, self.agents, None, self))
    def end_turn(self):
        if len(self.eventQueue) > 0:
            theEvent = self.eventQueue[0]
            self.eventQueue.remove(theEvent)
            return theEvent
        elif self.stability <= 0:
            endingMessage = "As your agents finish off the last of the guards, you are greeted, not by the blaring alarms and frantic reinforcements you've grown accustomed to evading, but by the sounds of fighting in the streets outside.\n\nThis final target has proven to be the last straw, and now the many power vacuums left in your wake are being leveraged by forces from all corners of the kingdom.  Opportunistic nobles turn on each other, and the royal army now fights a civil war.\n\nThrough the chaos, the people have found the courage to strike back at their oppressors; the Revolution has finally begun.  Your fight has ended in victory, and now the time has come for the masses to follow your example and throw off their shackles.\n\nLong live, "
            if self.player.noble == True:
                endingMessage += self.player.firstName + " " + self.player.lastName
            else:
                endingMessage += self.player.firstName
            endingMessage+= ", Champion of the Insurrection!"
            _w1.Final_Screen.tkraise()
            return 
        else:
            self.funds += 1000
            self.turn += 1
            for i in self.agents:
                if i.attr["health"] <= 0:
                    self.dead.append(i)
                    self.agents.remove(i)
                if i.attr["health"] < i.attr["hmax"] and i.attr["health"] > 0:
                    if i.attr["hmax"] - i.attr["health"] <= 10:
                        i.attr["health"] = i.attr["hmax"]
                    else:
                        i.attr["health"] += 10
            # if self.heat > 50:
            return "done"

    class Events:
        def __init__(self, location, team, noble, game):
            self.location = location
            self.difficulty = self.location.guards
            self.team = team
            self.noble = noble
            self.game = game
            self.part = [[]]
        def run(self, part=0, choice=0):
            return False
        def win(self):
            return
        def loss(self):
            return
    class Pack_up(Events):
        def __init__(self, location, team, noble, game):
            super().__init__(location, team, noble, game)
        def run(self, part=0, choice=0):
            theGame.pack_up(self.location)
            return "done"
    # class Raid(Events):
    #     def run(self, part=0, choice=0):
    #         return super().run(part, choice)
    class Assassinate(Events):
        def __init__(self, location, team, noble, game):
            super().__init__(location, team, noble, game)
            match self.difficulty:
                case 0:
                    if isinstance(self.noble, (Leader)):
                        noble = self.noble
                        self.enemies = [self.noble]
                    elif isinstance(self.noble, (Race)):
                        noble = cc.Reg().make(self.noble.race, "", "")
                        self.enemies = [cc.Reg().make(self.noble.race, "", ""), cc.Reg().make(self.noble.race, "", "")]
                case 10:
                    self.enemies = [cc.Watchman().make(self.noble.race, "", ""), cc.Watchman().make(self.noble.race, "", ""), noble]
                case 20:
                    self.enemies = [cc.Watchman().make(self.noble.race, "", ""), cc.Watchman().make(self.noble.race, "", ""), cc.Watchman().make(self.noble.race, "", ""), noble]
                case 30:
                    self.enemies = [cc.Watchman().make(self.noble.race, "", ""), cc.Watchman().make(self.noble.race, "", ""), cc.WatchmanVet().make(self.noble.race, "", ""), noble]
                case 40:
                    self.enemies = [cc.Soldier().make(self.noble.race, "", ""), cc.WatchmanVet().make(self.noble.race, "", ""), cc.Watchman().make(self.noble.race, "", ""), noble]
                case 50:
                    self.enemies = [cc.Soldier().make(self.noble.race, "", ""), cc.Soldier().make(self.noble.race, "", ""), cc.WatchmanVet().make(self.noble.race, "",""), noble]
                case 60:
                    self.enemies = [cc.Soldier().make(self.noble.race, "", ""), cc.Soldier().make(self.noble.race, "", ""), cc.Soldier().make(self.noble.race, "", ""), noble]
                case 70:
                    self.enemies = [cc.Soldier().make(self.noble.race, "", ""), cc.Soldier().make(self.noble.race, "", ""), cc.Captain().make(self.noble.race, "",""), noble]
                case 80:
                    self.enemies = [cc.Soldier().make(self.noble.race, "", ""), cc.Knight().make(self.noble.race,"",""), cc.Captain().make(self.noble.race, "",""), noble]
                case 90:
                    self.enemies = [cc.Knight().make(self.noble.race, "", ""), cc.Knight().make(self.noble.race, "", ""), cc.Captain().make(self.noble.race, "", ""), noble]
                case 100:
                    self.enemies = [cc.Knight().make(self.noble.race, "", ""), cc.Knight().make(self.noble.race, "", ""), cc.Knight().make(self.noble.race, "", ""), noble]
            self.battle = Combat(self.team, self.enemies)
            self.lineup = [self.battle.lineup, self.battle.player, self.battle.opps]
            for a in self.battle.opps:
                theOpps = self.battle.opps.copy()
                theOpps.remove(a)
                count = 1
                for b in theOpps:
                    if b[0].nickname == a[0].nickname:
                        if count == 1:
                            a[0].nickname += " " + str(count)
                            b[0].nickname += " " + str(count+1)
                            count += 1
                        else:
                            count += 1
                            b[0].nickname += " " + str(count)
            iteration = 1
            for i in self.team:
                if iteration == 1:
                    o = i
                elif i.skills["stealth"] > o.skills["stealth"]:
                    o = i
            self.attacker = o
            self.target = None
        def run(self, part=0, choice=0):
            opening = "Your target, " + self.noble.nickname + ", is protected by " + str(len(self.enemies)-1), " guards.\n\nDo you wish to proceed?"
            self.part = [[opening, "Proceed", "Retreat"], [True]]
            match choice:
                case 0:
                    return (self.part[part], part)
                case 1: 
                    _w1.Combat.tkraise()
                    enemies = []
                    for e in self.lineup[2]:
                        enemies.append(e[0].nickname)
                    _w1.enemyList['values'] = enemies
                    self.player = self.lineup[1][0]
                    _w1.activeAgentName.configure(text = self.player[0].nickname)
                    _w1.enemyList.set(enemies[0])
                    for i in self.lineup[2]:
                        if i[0].nickname == enemies[0]:
                            _w1.enemy_health.configure(text = str(i[0].attr["health"]))
                            _w1.enemy_agility.configure(text = str(i[0].attr["agility"]))
                            _w1.enemy_ap.configure(text = str(i[0].attr["ap"]))
                            _w1.enemy_armor.configure(text = str(i[0].attr["armor"]))
                            self.target = i
                            values = self.plot(self.player, self.target)
                            difficulty, minDam, maxDam = values[0], values[1], values[3]
                            thePlot = self.player[0].nickname + " will need to roll " + str(difficulty) + " or higher in order to deal " + str(minDam) + "-" + str(maxDam) + " damage"
                            _w1.attackPlot.configure(text = thePlot)
                    self.mode = "fight"
                    return "fight"
                case 2:
                    return "done"
        def fight(self):
            if self.mode == "stealth":
                pass
            else:
                while True:
                    result = self.battle.runTurn()
                    if result in self.battle.opps:
                        _w1.top.after(500, _w1.active_team.configure(text = "Opponents"))
                        # _w1.active_team.after(500, _w1.active_team.configure(text = "Opponents"))
                        self.status = "opps"
                        _w1.active_team.configure(text = "Opponents")
                        while True:
                            target = random.choice(self.battle.player)
                            if target[2] == True:
                                break
                        values = self.battle.plotAttack(result, target)
                        outcome = Dice.quietRoll(Dice, values[0], values[0]-1)
                        match outcome:
                            case 3:
                                self.battle.launchAttack(result, target, values[3])
                                theText = result[0].nickname + " struck " + target[0].nickname + " for " + str(values[3]) + " damage"
                            case 2:
                                self.battle.launchAttack(result, target, values[2])
                                theText = result[0].nickname + " struck " + target[0].nickname + " for " + str(values[2]) + " damage"
                            case 1:
                                self.battle.launchAttack(result, target, values[1])
                                theText = result[0].nickname + " struck " + target[0].nickname + " for " + str(values[1]) + " damage"
                            case __:
                                theText = result[0].nickname + " missed " + target[0].nickname
                        if target[0].attr["health"] <= 0:
                            theText += ", killing "
                            if target[0].sex == "male":
                                theText += "him"
                            else:
                                theText += "her"
                            _w1.attackPlot.configure(text = "")
                        _w1.dialogueWindow.configure(text = theText)
                        print(theText)
                    elif result in self.battle.player:
                        self.player = result
                        self.status = "player"
                        _w1.active_team.configure(text = "Player")
                        _w1.activeAgentName.configure(text = self.player[0].nickname)
                        _w1.agent_health.configure(text = str(self.player[0].attr["health"]))
                        _w1.agent_agility.configure(text = str(self.player[0].attr["agility"]))
                        _w1.agent_armor.configure(text = str(self.player[0].attr["armor"]))
                        _w1.agent_ap.configure(text = str(self.player[0].attr["ap"]))
                        if self.target != None:
                            values = self.plot(self.player, self.target)
                            difficulty, minDam, maxDam = values[0], values[1], values[3]
                            thePlot = self.player[0].nickname + " will need to roll " + str(difficulty) + " or higher in order to deal " + str(minDam) + "-" + str(maxDam) + " damage"
                            _w1.attackPlot.configure(text = thePlot)
                        else:
                            _w1.attackPlot.configure(text = "")
                        return
                    elif result == True:
                        print("win")
                        _w1.total_funds.set(str(theGame.funds))
                        _w1.total_heat.set(str(theGame.heat))
                        _w1.total_stability.set(str(theGame.stability) + "%")
                        _w1.turn_no.set(str(theGame.turn))
                        close_submenu()
                        self.win()
                        return
                    else:
                        _w1.total_funds.set(str(theGame.funds))
                        _w1.total_heat.set(str(theGame.heat))
                        _w1.total_stability.set(str(theGame.stability) + "%")
                        _w1.turn_no.set(str(theGame.turn))
                        close_submenu()
                        return
        def stealthPlot(self):
            return self.battle.plotStealth(self.attacker, self.noble)
        def plot(self, attacker, defender):
            return self.battle.plotAttack(attacker, defender)
        def launch(self):
            if self.status == "player":
                values = self.battle.plotAttack(self.player, self.target)
                outcome = Dice.roll(Dice, values[0], values[0]-1)
                match outcome:
                    case 3:
                        self.battle.launchAttack(self.player, self.target, values[3])
                        theText = self.player[0].nickname + " struck " + self.target[0].nickname + " for " + str(values[3]) + " damage"
                    case 2:
                        self.battle.launchAttack(self.player, self.target, values[2])
                        theText = self.player[0].nickname + " struck " + self.target[0].nickname + " for " + str(values[2]) + " damage"
                    case 1:
                        self.battle.launchAttack(self.player, self.target, values[1])
                        theText = self.player[0].nickname + " struck " + self.target[0].nickname + " for " + str(values[1]) + " damage"
                    case __:
                        theText = self.player[0].nickname + " missed " + self.target[0].nickname
                if self.target[0].attr["health"] <= 0:
                    theText += ", killing "
                    if self.target[0].sex == "male":
                        theText += "him"
                    else:
                        theText += "her"
                    _w1.attackPlot.configure(text = "")
                    for i in self.lineup[2]:
                        if i[2] == True:
                            _w1.enemyList.set(i[0].nickname)
                            self.target = i
                            break
                    enemies = []
                    for e in self.lineup[2]:
                        enemies.append(e[0].nickname)
                    _w1.enemyList['values'] = enemies
                _w1.dialogueWindow.configure(text = theText)
                _w1.enemy_health.configure(text = str(self.target[0].attr["health"]))
                _w1.enemy_agility.configure(text = str(self.target[0].attr["agility"]))
                _w1.enemy_ap.configure(text = str(self.target[0].attr["ap"]))
                _w1.enemy_armor.configure(text = str(self.target[0].attr["armor"]))
                time.sleep(1)
                Dice.reset(Dice)
                self.fight()
        def win(self):
            self.location.nobles.remove(self.noble)
            self.location.heat += 20
            for i in self.enemies:
                for o in i.equip:
                    if (isinstance(i.equip[o], list) == False) and (i.equip[o].name != "empty"):
                            print("loot acquired")
                            self.game.itempool.append(i.equip[o])
            self.game.heat += 10
            self.game.funds += 5000
            self.location.stability += -20
            self.game.stability += -10
            _w1.dialogueWindow.configure(text = "")
            _w1.total_funds.set(str(theGame.funds))
            _w1.total_heat.set(str(theGame.heat))
            _w1.total_stability.set(str(theGame.stability) + "%")
            _w1.turn_no.set(str(theGame.turn))
            _w1.fight_result_label.configure(text = "SUCCESS")
            _w1.okay_button.configure(text = "Long live the Revolution!")
            adjective = random.choice(["haughty", "mighty", "petulent", "foolish", "cruel", "wicked", "evil", 
                                       "arrogant", "worthless", "villainous", "devilish", "invincible", "'holy'",
                                       "'heroic'", "pitiful", "vile", "feeble", "degenerate", "cowardly", "heathen",
                                       "heretic", "great", "immortal", "foul", "untouchable"])
            verb = random.choice(["struck down", "slain", "assassinated", "crushed", "ended", "killed", 
                                  "slaughtered", "eviscerated", "purged", "overthrown", "annihilated", "exterminated",
                                  "finished"])
            if self.noble.sex == "male":
                pro1 = "his"
            else:
                pro1 = "her"
            _w1.fight_result_message.configure(text = "The "+adjective+" "+self.noble.nickname+" has been "+verb+" at last.  The corpses of "+pro1+" guards have been stripped of their equipment and "+pro1+" coffers have been emptied into your own.\n\nLong live the revolution!")
            _w1.Fight_result_screen.tkraise()
            _w1.target.set("")
            editAgent(True)
            editTarget(True)
    class Recruit(Events):
        def __init__(self, location, team, noble, game):
            super().__init__(location, team, noble, game)
            iteration = 1
            for i in self.team:
                if iteration == 1:
                    o = i
                elif i.skills["speech"] > o.skills["speech"]:
                    o = i
            self.diplomat = o
        def run(self, part=0, choice=0):
            match choice:
                case 0:
                    theRaces = self.location.pops.copy()
                    recruits = (self.diplomat.skills["speech"])//10
                    changed = 0
                    b = 0
                    for i in theRaces:
                            theRaces[i] += b
                            b = theRaces[i]
                            c = i
                    if recruits > 0:
                        for a in range(recruits):
                            changed += 1
                            value = random.randint(1, theRaces[c])
                            iteration = 1
                            self.theirNames = ""
                            for o in theRaces:
                                if iteration == 1 and theRaces[o] > value:
                                    keep = o
                                elif iteration > 1 and theRaces[o] > value and theRaces[o] < theRaces[keep]:
                                    keep = o
                                elif theRaces[o] == value:
                                    keep = o
                                    break
                                else:
                                    iteration += -1
                                iteration += 1
                            ihateliving = cc.Reg()
                            new_recruit = ihateliving.make(keep)
                            if changed < recruits:
                                if new_recruit.noble == False:
                                    self.theirNames += new_recruit.firstName + ", "
                                    new_recruit.nickname = new_recruit.firstName
                                else:
                                    self.theirNames += new_recruit.firstName + " " + new_recruit.lastName + ", "
                                    new_recruit.nickname = new_recruit.firstName + " " + new_recruit.lastName
                            else:
                                if new_recruit.noble == False:
                                    self.theirNames += "and " + new_recruit.firstName
                                    new_recruit.nickname = new_recruit.firstName
                                else:
                                    self.theirNames += "and " + new_recruit.firstName + " " + new_recruit.lastName
                                    new_recruit.nickname = new_recruit.firstName + " " + new_recruit.lastName
                            self.game.agents.append(new_recruit)
                            theNumbers = "Recruited: " + self.theirNames
                        return [[theNumbers, "Okay", "That's it?", "Wow"]]
                    else:
                        return [["Nobody wanted to join you...", "Okay", "That's unfortunate", "well... guess I'm softlocked"]]
                case __:
                    return "done"
    class BuyGear(Events):
        def __init__(self, location, team, noble, game):
            super().__init__(location, team, noble, game)
        def run(self, part=0, choice=0):
            baseZero = "You arrive at the market to witness a bustling sea of vendors and their goods"
            self.part = [[baseZero, "Buy Sword (100)", "Buy Longsword (150)", "More"], [baseZero, "Buy Iron Dagger (100)", "Buy Assassin's Dagger (300)", "More"], [baseZero, "Buy Light Cuirass (500)", "Buy Heavy Cuirass (1000)", "More"], [baseZero, "Back", "Leave", " "]]
            match part:
                case 0:
                    match choice:
                        case 0:
                            return (self.part[part], part)
                        case 1:
                            if self.game.funds >= 100:
                                self.game.funds += -100
                                self.game.itempool.append(equipment.Sword_1())
                                _w1.total_funds.set(str(theGame.funds))
                                _w1.total_heat.set(str(theGame.heat))
                                _w1.total_stability.set(str(theGame.stability) + "%")
                                _w1.turn_no.set(str(theGame.turn))
                                return (["Sword purchased for 100 gold"], part)
                            else:
                                return (["Need more funds (current amount: " + str(self.game.funds) + ")"], part)
                        case 2:
                            if self.game.funds >= 150:
                                self.game.funds += -150
                                self.game.itempool.append(equipment.Sword_2())
                                _w1.total_funds.set(str(theGame.funds))
                                _w1.total_heat.set(str(theGame.heat))
                                _w1.total_stability.set(str(theGame.stability) + "%")
                                _w1.turn_no.set(str(theGame.turn))
                                return (["Longsword purchased for 150 gold"], part)
                            else:
                                return (["Need more funds (current amount: " + str(self.game.funds) + ")"], part)
                        case 3: 
                            return (self.part[1], 1)
                case 1:
                    match choice:
                        case 0:
                            return (self.part[part], part)
                        case 1:
                            if self.game.funds >= 100:
                                self.game.funds += -100
                                self.game.itempool.append(equipment.Dagger_1())
                                _w1.total_funds.set(str(theGame.funds))
                                _w1.total_heat.set(str(theGame.heat))
                                _w1.total_stability.set(str(theGame.stability) + "%")
                                _w1.turn_no.set(str(theGame.turn))
                                return (["Iron Dagger purchased for 100 gold"], part)
                            else:
                                return (["Need more funds (current amount: " + str(self.game.funds) + ")"], part)
                        case 2:
                            if self.game.funds >= 300:
                                self.game.funds += -300
                                self.game.itempool.append(equipment.Dagger_2())
                                _w1.total_funds.set(str(theGame.funds))
                                _w1.total_heat.set(str(theGame.heat))
                                _w1.total_stability.set(str(theGame.stability) + "%")
                                _w1.turn_no.set(str(theGame.turn))
                                return (["Assassin's Dagger purchased for 300 gold"], part)
                            else:
                                return (["Need more funds (current amount: " + str(self.game.funds) + ")"], part)
                        case 3:
                            return (self.part[2], 2)
                case 2:
                    match choice:
                        case 0:
                            return (self.part[part], part)
                        case 1:
                            if self.game.funds >= 500:
                                self.game.funds += -500
                                self.game.itempool.append(equipment.LightCuirass())
                                _w1.total_funds.set(str(theGame.funds))
                                _w1.total_heat.set(str(theGame.heat))
                                _w1.total_stability.set(str(theGame.stability) + "%")
                                _w1.turn_no.set(str(theGame.turn))
                                return (["Light Cuirass purchased for 500 gold"], part)
                            else:
                                return (["Need more funds (current amount: " + str(self.game.funds) + ")"], part)
                        case 2:
                            if self.game.funds >= 1000:
                                self.game.funds += -1000
                                self.game.itempool.append(equipment.HeavyCuirass())
                                _w1.total_funds.set(str(theGame.funds))
                                _w1.total_heat.set(str(theGame.heat))
                                _w1.total_stability.set(str(theGame.stability) + "%")
                                _w1.turn_no.set(str(theGame.turn))
                                return (["Heavy Cuirass purchased for 1000 gold"], part)
                            else:
                                return (["Need more funds (current amount: " + str(self.game.funds) + ")"], part)
                        case 3:
                            return (self.part[3], 3)
                case 3:
                    match choice:
                        case 0:
                            return (self.part[part], part)
                        case 1:
                            return (self.part[0], 0)
                        case 2:
                            return "done"
                        case 3:
                            return (self.part[part], part)
            return
        
    def getRegion(self, which):
        return self.places[which]
    
    def makeNobles(self, location, proportions):
        theNobles = []
        #creating the nobles themselves
        for i in proportions:
            for u in range(proportions[i]):
                temp = Leader(i, "", True, "", "", location)
                temp2 = findRace(i)
                match temp.sex:
                    case "male":
                        temp.prefix = random.choice(temp2.mprefs)
                    case "female":
                        temp.prefix = random.choice(temp2.fprefs)
                theNobles.append(temp)
        return theNobles

    class location:
        def __init__(self, pops={}, nobles=[], home="none", bases=None, stability=0, guards=0, sympathy=0, heat=0):
            self.pops = pops
            self.nobles = nobles
            if nobles == []:
                self.makeNobles()
                self.setNicknames()
            self.home = home
            self.bases = bases
            self.stability = stability
            self.guards = guards
            self.sympathy = sympathy
            self.heat = heat   
            self.id = "placeholder"
        def makeNobles(self):
            return
        def setNicknames(self):
            for i in self.nobles:
                i.nickname = i.prefix + " " + i.firstName + " " + i.lastName
        def save(self):
            return self.id
    class Byzend(location):
        def __init__(self, pops={"Goblin":50, "Orc":5, "Ogre":3, "Kobold":2}, nobles=[], 
                     home = "Goblin", bases=None, stability=40, guards=10, sympathy=50, heat=0):
            super().__init__(pops, nobles, home, bases, stability, guards, sympathy, heat)
            self.name = "Byzend"
            self.neighbors = ["Ushnakh", "Gorkhen", "Elden"]
            self.id = self.name
        def makeNobles(self):
            self.nobles = GameLoop.makeNobles(GameLoop, self, {"Goblin":8})
            return
    class Gorkhen(location):
        def __init__(self, pops={"Orc":15, "Goblin":15, "Ogre":10, "Human":5, "Dwarf":7, "Kobold":4, "Hiver":5}, 
                     nobles=[], home="Ogre", bases=None, stability=65, guards=30, sympathy=35,  heat=0):
            super().__init__(pops, nobles, home, bases, stability, guards, sympathy,  heat)
            self.name = "Gorkhen"
            self.neighbors = ["Byzend", "Ushnakh", "Elden", "Darkhour"]
            self.id = self.name
        def makeNobles(self):
            self.nobles = GameLoop.makeNobles(GameLoop, self, {"Orc":5, "Goblin":2, "Dwarf":2, "Human":1})
            for i in self.nobles:
                match i.race:
                    case "Human":
                        i.prefix = random.choice(["Governor"])
                    case "Dwarf":
                        i.prefix = random.choice(["General", "Axelord"])
            return
    class Ushnakh(location):
        def __init__(self, pops={"Orc":30, "Goblin":5, "Ogre":8, "Human":5, "Dwarf":5}, nobles=[], home="Orc", 
                     bases=None, stability=40, guards=20, sympathy=15,  heat=0):
            super().__init__(pops, nobles, home, bases, stability, guards, sympathy,  heat)
            self.name = "Ushnakh"
            self.neighbors = ["Byzend", "Gorkhen", "Darkhour"]
            self.id = self.name
        def makeNobles(self):
            self.nobles = GameLoop.makeNobles(GameLoop, self, {"Orc":9, "Dwarf":1, "Human":1})
            for i in self.nobles:
                match i.race:
                    case "Dwarf":
                        i.prefix = "General"
                    case "Human":
                        match i.sex:
                            case "male":
                                i.prefix = "Sir"
                            case "female":
                                i.prefix = "Dame"
            return 
    class Darkhour(location):
        def __init__(self, pops={"Human":10, "Orc":10, "Dwarf":10, "Ogre":5, "Goblin":5, "Kobold":1}, nobles=[], 
                     home="none", bases=None, stability=80, guards=80, sympathy=5,  heat=0):
            super().__init__(pops, nobles, home, bases, stability, guards, sympathy,  heat)
            self.name = "Darkhour"
            self.neighbors = ["Ushnakh", "Gorkhen", "Elden", "Media", "Centria"]
            self.id = self.name
        def makeNobles(self):
            self.nobles = GameLoop.makeNobles(GameLoop, self, {"Human":3, "Dwarf":3, "Orc":2})
            for i in self.nobles:
                match i.race:
                    case "Human":
                        match i.sex:
                            case "male":
                                i.prefix = random.choice(["Sir", "General", "Corporal"])
                            case "female":
                                i.prefix = random.choice(["Dame", "General"])
                    case "Dwarf":
                        match i.sex:
                            case "female":
                                i.prefix = random.choice(["Shieldmaiden", "Valkyrie", "General"])
                            case "male":
                                i.prefix = random.choice(["General", "Axemaster", "Corporal"])
                    case "Orc":
                        i.prefix = random.choice(["Corporal", "Sergeant-At-Arms"])
            return 
    class Elden(location):
        def __init__(self, pops={"Dwarf":15, "Elf":13, "Hiver":20, "Kobold":10, "Goblin":5}, nobles=[], 
                     home="none", bases=None, stability=35, guards=40, sympathy=0, heat=0):
            super().__init__(pops, nobles, home, bases, stability, guards, sympathy,  heat)
            self.name = "Elden Fields"
            self.neighbors = ["Darkhour", "Gorkhen", "Byzend", "Hevok", "Graygold"]
            self.id = "Elden"
        def makeNobles(self):
            self.nobles = GameLoop.makeNobles(GameLoop, self, {"Dwarf":3, "Hiver":4, "Elf":2})
            for i in self.nobles:
                match i.race:
                    case "Hiver":
                        i.prefix = random.choice(["Vicereine"])
            return
    class Graygold(location):
        def __init__(self, pops={"Dwarf":20, "Ogre":5, "Hiver":10, "Goblin":0}, nobles=[], 
                     home="none", bases=None, stability=70, guards=30, sympathy=0,  heat=0):
            super().__init__(pops, nobles, home, bases, stability, guards, sympathy,  heat)
            self.name = "Graygold"
            self.neighbors = ["Centria", "Highland", "Faewind", "Elden"]
            self.id = self.name
        def makeNobles(self):
            self.nobles = GameLoop.makeNobles(GameLoop, self, {"Dwarf":7, "Hiver":3})
            for i in self.nobles:
                match i.race:
                    case "Hiver":
                        i.prefix = random.choice(["Vicereine"])
            return
    class Hevok(location):
        def __init__(self, pops={"Hiver":40, "Goblin":0}, nobles=[], home="Hiver", 
                     bases=None, stability=100, guards=50, sympathy=0,  heat=0):
            super().__init__(pops, nobles, home, bases, stability, guards, sympathy,  heat)
            self.name = "Hevok"
            self.neighbors = ["Elden"]
            self.id = self.name
        def makeNobles(self):
            self.nobles = GameLoop.makeNobles(GameLoop, self, {"Hiver":9})
            return
    class Centria(location):
        def __init__(self, pops={"Goblin":5, "Hobbit":10, "Elf":20, "Dwarf":20, "Human":20, "Orc":6, "Ogre":2, "Kobold":3, "Hiver":8}, 
                     nobles=[], home="none", bases=None, stability=90, guards=100, sympathy=0,  heat=0):
            super().__init__(pops, nobles, home, bases, stability, guards, sympathy,  heat)
            self.name = "Centria"
            self.neighbors = ["Dirennia", "Merwendel", "Highland", "Graygold", "Darkhour", "Hobbiton", "Elden", "Media"]
            self.id = self.name
        def makeNobles(self):
            self.nobles = GameLoop.makeNobles(GameLoop, self, {"Hiver":1, "Dwarf":3, "Human":3, "Elf":3, "Orc":1})
            return
    class Media(location):
        def __init__(self, pops={"Human":20, "Hobbit":15, "Elf":7, "Orc":5, "Ogre":5, "Goblin":0}, 
                     nobles=[], home="none", bases=None, stability=90, guards=20, sympathy=0,  heat=0):
            super().__init__(pops, nobles, home, bases, stability, guards, sympathy,  heat)
            self.name = "Media"
            self.neighbors = ["Dirennia", "Centria", "Hobbiton", "Darkhour"]
            self.id = self.name
        def makeNobles(self):
            self.nobles = GameLoop.makeNobles(GameLoop, self, {"Human":6, "Hobbit":3})
            return
    class Highland(location):
        def __init__(self, pops={"Goblin":5, "Dwarf":45}, nobles=[], home="none", bases=None, 
                     stability=80, guards=50, sympathy=0,  heat=0):
            super().__init__(pops, nobles, home, bases, stability, guards, sympathy,  heat)
            self.name = "Highland Helm"
            self.neighbors = ["Centria", "Graygold", "Faewind", "Merwendel"]
            self.id = "Highland"
        def makeNobles(self):
            self.nobles = GameLoop.makeNobles(GameLoop, self, {"Dwarf":9})
            return
    class Faewind(location):
        def __init__(self, pops={"Elf":20, "Dwarf":15, "Hiver":10, "Goblin":0}, nobles=[], 
                     home="none", bases=None, stability=60, guards=40, sympathy=0,  heat=0):
            super().__init__(pops, nobles, home, bases, stability, guards, sympathy,  heat)
            self.name = "Faewind"
            self.neighbors = ["Merwendel", "Highland", "Graygold"]
            self.id = self.name
        def makeNobles(self):
            self.nobles = GameLoop.makeNobles(GameLoop, self, {"Elf":4, "Dwarf":3, "Hiver":2})
            return
    class Merwendel(location):
        def __init__(self, pops={"Goblin":5, "Elf":45}, nobles=[], home="none", 
                     bases=None, stability=100, guards=30, sympathy=0,  heat=0):
            super().__init__(pops, nobles, home, bases, stability, guards, sympathy,  heat)
            self.name = "Merwendel"
            self.neighbors = ["Dirennia", "Centria", "Highland", "Faewind"]
            self.id = self.name
        def makeNobles(self):
            self.nobles = GameLoop.makeNobles(GameLoop, self, {"Elf":9})
            return
    class Hobbiton(location):
        def __init__(self, pops={"Hobbit":45, "Goblin":0}, nobles=[], home="none", bases=None, 
                     stability=100, guards=0, sympathy=0,  heat=0):
            super().__init__(pops, nobles, home, bases, stability, guards, sympathy,  heat)
            self.name = "Hobbiton"
            self.neighbors = ["Dirennia", "Centria", "Media"]
            self.id = self.name
        def makeNobles(self):
            self.nobles = GameLoop.makeNobles(GameLoop, self, {"Hobbit":9})
            return
    class Dirennia(location):
        def __init__(self, pops={"Human":40, "Goblin":0}, nobles=[], home="none", bases=None, 
                     stability=80, guards=50, sympathy=0,  heat=0):
            super().__init__(pops, nobles, home, bases, stability, guards, sympathy,  heat)
            self.name = "Dirennia"
            self.neighbors = ["Merwendel", "Centria", "Hobbiton", "Media"]
            self.id = self.name
        def makeNobles(self):
            self.nobles = GameLoop.makeNobles(GameLoop, self, {"Human":9})
            return

def main(*args):
    '''Main entry point for the application.'''
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1, noble, skillpts, fight, stealth, speech, learning, management, gender, player, theGame, agents, agentsChosen
    global agentCandidates, eventButtons
    _top1 = root
    # _w1 = gui.Toplevel1(_top1)
    _w1 = gui.Goblinsurrection(_top1)
    noble = False
    gender = "male"
    skillpts = 30
    fight = 1
    stealth = 1
    speech = 1
    learning = 1
    management = 1
    # Creates a toplevel widget.
    # global _top1, _w1
    # _top1 = tk.Toplevel(root)
    # _w1 = gui.Goblinsurrection(_top1)
    _w1.Start_menu.tkraise
    eventButtons = [_w1.event_button1, _w1.event_button2, _w1.event_button3]
    _w1.mission_type.configure(exportselection=False)
    _w1.target.configure(exportselection=False)
    root.mainloop()

def raiseFrame(frame):
    global lastFrame 
    lastFrame= frame
    frame.tkraise()

def changeRank(*args):
    global noble
    noble = not noble
    if noble == False:
        _w1.Entry1_1.configure(state="disabled")
        _w1.Label1_1.configure(foreground="#c8c8c8")
        _w1.ranktxt.set("Commoner")
    else:
        _w1.Entry1_1.configure(state="normal")
        _w1.Label1_1.configure(foreground="white")
        _w1.ranktxt.set("Noble")

def exit(*args):
    Dice.cleanup(Dice)
    quit()
def upFight(*args):
    global fight, skillpts
    if skillpts > 0:
        skillpts += -1
        fight+=1
        _w1.stPts.set(str(skillpts))
        _w1.stfight.set(str(fight))
    return
def upStealth(*args):
    global stealth, skillpts
    if skillpts > 0:
        skillpts += -1
        stealth+=1
        _w1.stPts.set(str(skillpts))
        _w1.ststealth.set(str(stealth))
    return
def upSpeech(*args):
    global speech, skillpts
    if skillpts > 0:
        skillpts += -1
        speech+=1
        _w1.stPts.set(str(skillpts))
        _w1.stspeech.set(str(speech))
    return
def upLearning(*args):
    global learning, skillpts
    if skillpts > 0:
        skillpts += -1
        learning+=1
        _w1.stPts.set(str(skillpts))
        _w1.stlearning.set(str(learning))
    return
def upManagement(*args):
    global management, skillpts
    if skillpts > 0:
        skillpts += -1
        management+=1
        _w1.stPts.set(str(skillpts))
        _w1.stmanagement.set(str(management))
    return
def downFight(*args):
    global fight, skillpts
    if fight > 1:
        skillpts += 1
        fight+=-1
        _w1.stPts.set(str(skillpts))
        _w1.stfight.set(str(fight))
    return
def downStealth(*args):
    global stealth, skillpts
    if stealth > 1:
        skillpts += 1
        stealth += -1
        _w1.stPts.set(str(skillpts))
        _w1.ststealth.set(str(stealth))
    return
def downSpeech(*args):
    global speech, skillpts
    if speech > 1:
        skillpts += 1
        speech += -1
        _w1.stPts.set(str(skillpts))
        _w1.stspeech.set(str(speech))
    return
def downLearning(*args):
    global learning, skillpts
    if learning > 1:
        skillpts += 1
        learning += -1
        _w1.stPts.set(str(skillpts))
        _w1.stlearning.set(str(learning))
    return
def downManagement(*args):
    global management, skillpts
    if management > 1:
        skillpts += 1
        management += -1
        _w1.stPts.set(str(skillpts))
        _w1.stmanagement.set(str(management))
    return

def new_game(*args):
    global theGame
    theGame = GameLoop()
    raiseFrame(_w1.Character_creator_1)
    return

def load_save(*args):
    if _debug:
        print('gui_support.load_save')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

def options(*args):
    if _debug:
        print('gui_support.options')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

def main_menu(*args):
    raiseFrame(_w1.Start_menu)
    return

def start_loc(*args):
    global player, fight, stealth, speech, learning, management, theGame
    lastName = ""
    raiseFrame(_w1.Start_location)
    _w1.choose_spot.tkraise()
    if noble==True:
        lastName = _w1.lastName 
    player = Character("Goblin", gender, noble, _w1.firstName, lastName)
    player.skills = {"fight":fight, "stealth":stealth, "speech":speech, "learning":learning, "management":management}
    theGame.setPlayer(player)
    return
def choose_location(*args):
    _w1.choose_spot.tkraise()
    return

def byzend_details(*args):
    global theGame, player
    player.location = theGame.getRegion("Byzend")
    _w1.region_name.set("Byzend")
    _w1.loc_desc.set("  By far the poorest region in the kingdom, the so-called 'Goblin homeland' of Byzend is, in reality, little more than a reservation allotted to contain the bulk of Goblins away from the 'civilized' centers of the kingdom.\n  Within the wretched slums of this place lie the few existing centers of power for Goblin nobility, whose members cling to what little power they have by starving their subjects into submission.")
    _w1.loc_pros.set("")
    _w1.loc_cons.set("")
    raiseFrame(_w1.location_details)
    return
def gorkhen_details(*args):
    global theGame, player
    player.location = theGame.getRegion("Gorkhen")
    _w1.region_name.set("Gorkhen")
    _w1.loc_desc.set("  Long ago, this place was home to the only known Ogre nation. Its memory faded with the rise of the Dark Lord, who used this region as a breeding ground for the Ogre shock divisions of the Crooked Legions.\n   Today, Gorkhen is a melting-pot of the races known as 'servants of darkness,' whose leaders are carefully monitored by a garrison of wary Dwarves and Humans. Were it not for the lucrative practice of Ogre slavery, the Kingdom likely would have purged this place of all greenskins.")
    _w1.loc_pros.set("")
    _w1.loc_cons.set("")
    raiseFrame(_w1.location_details)
    return
def ushnakh_details(*args):
    global theGame, player
    player.location = theGame.getRegion("Ushnakh")
    _w1.region_name.set("Ushnakh")
    _w1.loc_desc.set("  The region of Ushnakh is the only former territory of the Dark Lord to have been integrated into Centria not by conquest, but by treaty with its inhabitants.\n  The Orcs of Ushnakh have earned their land through centuries of bloodshed, and only now do they find themselves in danger of losing it to internal power squabbles, as dozens of minor clan leaders battle each other for full control of this place.")
    _w1.loc_pros.set("")
    _w1.loc_cons.set("")
    raiseFrame(_w1.location_details)
    return
def elden_details(*args):
    global theGame, player
    player.location = theGame.getRegion("Elden")
    _w1.region_name.set("The Elden Fields")
    _w1.loc_desc.set("  The former breadbasket of the Crooked Legions, the Elden Fields were discovered shortly after the Second War of Armageddon, leading to a mass-migration of Elves and Dwarves.  It was here that the Hivers were first encountered, and their grip on this region has only tightened since then.\n  Today, the Elden Fields are home to the fiercest territorial disputes in the Kingdom, with Hivers, Dwarves, and Elves waging cold wars against one another, leaving the region's many Kobold tribes caught in the middle.\n    Were a civil war to erupt, its epicenter would begin here.")
    _w1.loc_pros.set("")
    _w1.loc_cons.set("")
    raiseFrame(_w1.location_details)
    return
def hevok_details(*args):
    global theGame, player
    player.location = theGame.getRegion("Hevok")
    _w1.region_name.set("Hevok")
    _w1.loc_desc.set("  A seemingly desolate land, Hevok is home to little but Hivers, and remains the only region neighboring the Elden Fields to be devoid of that place's Kobolds--likely due to Hiver extermination.\n  To this day, it is often debated as to why the Greater Hives allowed this territory to be ceded to Centria, with many suspecting that its ant-like inhabitants intend to conquer the Kingdom from within.")
    _w1.loc_pros.set("")
    _w1.loc_cons.set("")
    raiseFrame(_w1.location_details)
    return
def darkhour_details(*args):
    global theGame, player
    player.location = theGame.getRegion("Darkhour")
    _w1.region_name.set("Darkhour")
    _w1.loc_desc.set("  The stronghold of Centria's military lies at the border between the races of the light and the servants of darkness.  Here, amidst these ranks alone can one find the only Orcs to receive near-favorable treatment from their Human and Dwarf comrades.")
    _w1.loc_pros.set("")
    _w1.loc_cons.set("")
    raiseFrame(_w1.location_details)
    return
def media_details(*args):
    global theGame, player
    player.location = theGame.getRegion("Media")
    _w1.region_name.set("Media")
    _w1.loc_desc.set("  The primary trade port of the Kingdom, Media is one of the few places outside of Hobbiton to feature that place's inhabitants in significant numbers")
    _w1.loc_pros.set("")
    _w1.loc_cons.set("")
    raiseFrame(_w1.location_details)
    return
def graygold_details(*args):
    global theGame, player
    player.location = theGame.getRegion("Graygold")
    _w1.region_name.set("Graygold")
    _w1.loc_desc.set("  There exists no greater reminder of the Dwarves' fading prominence within the Kingdom than the mountains of Graygold. Held exclusively by Dwarves for centuries, this region has since seen a slow trickle of Hiver nobles, who have established their own mines to rival the works of the Dwarves.\n   Though its first inhabitants remain the de facto rulers of Graygold, this demographic shift has been enough to make the Dwarven royalty in Highland Helm fear for their race's status within the Ruling Three.  Whether this fear will drive them into unusual alliances remains to be seen.")
    _w1.loc_pros.set("")
    _w1.loc_cons.set("")
    raiseFrame(_w1.location_details)
    return
def centria_details(*args):
    global theGame, player
    player.location = theGame.getRegion("Centria")
    _w1.region_name.set("Centria")
    _w1.loc_desc.set("  The capital of the Kingdom, this province is home to some of every race that inhabits its vassal states.\n  It's also one of the most well-guarded regions in the world, a correction from the Second War of Armageddon, which nearly saw this place's towers dashed to the ground by the Crooked Legions.  Attempting to wage war here today would be suicide.")
    _w1.loc_pros.set("")
    _w1.loc_cons.set("")
    raiseFrame(_w1.location_details)
    return
def faewind_details(*args):
    global theGame, player
    player.location = theGame.getRegion("Faewind")
    _w1.region_name.set("Faewind")
    _w1.loc_desc.set("  Faewind has been the site of struggle between Elves and Dwarves for centuries.  Its rich veins and magical trees remain untapped due to the many treaties between the Elves and Dwarves.\n  Now the Hivers have arrived to bicker over this land as well, adding yet more volatile fuel to this powder keg.")
    _w1.loc_pros.set("")
    _w1.loc_cons.set("")
    raiseFrame(_w1.location_details)
    return
def hobbiton_details(*args):
    global theGame, player
    player.location = theGame.getRegion("Hobbiton")
    _w1.region_name.set("Hobbiton")
    _w1.loc_desc.set("  Home to the titular Hobbits, Hobbiton is by far and away the most peaceful place in all of Centria.  Not a single guard patrols these hamlets, nor do any villains harass their inhabitants.\n  Yet.")
    _w1.loc_pros.set("")
    _w1.loc_cons.set("")
    raiseFrame(_w1.location_details)
    return
def highland_details(*args):
    global theGame, player
    player.location = theGame.getRegion("Highland")
    _w1.region_name.set("Highland Helm")
    _w1.loc_desc.set("  The only Dwarven Helm to reside outside of a Dwarven kingdom, the Highland Helm stands tall as a monument to the enduring alliance between Humans, Elves, and Dwarves")    
    _w1.loc_pros.set("")
    _w1.loc_cons.set("")
    raiseFrame(_w1.location_details)
    return
def merwendel_details(*args):
    global theGame, player
    player.location = theGame.getRegion("Merwendel")
    _w1.region_name.set("Merwendel")
    _w1.loc_desc.set("  The center for the Elven Church is, undoubtedly, one of the most beautiful places in the Kingdom, yet this beauty is sustained through cruelty behind closed doors.  For, despite the Elves' opposition to Ogre slavery, the magic that fuels their paradise relies almost entirely on the continuous sacrifice of Goblin slaves.")
    _w1.loc_pros.set("")
    _w1.loc_cons.set("")
    raiseFrame(_w1.location_details)
    return
def dirennia_details(*args):
    global theGame, player
    player.location = theGame.getRegion("Dirennia")
    _w1.region_name.set("Dirennia")
    _w1.loc_desc.set("  Home to the oldest human settlements in the world, Dirennia's history is one of unification, strife, advancement, and regression.\n  Whether this age is part of Dirennia's rise or its fall, the cycle shall continue regardless.")
    _w1.loc_pros.set("")
    _w1.loc_cons.set("")
    raiseFrame(_w1.location_details)
    return

def sex_change(*args):
    global gender
    if gender == "male":
        gender = "female"
        _w1.sextxt.set(str("Female"))
    else:
        gender = "male"
        _w1.sextxt.set(str("Male"))
    return

def keep_agent1(*args):
    global agents, agentsChosen, agentCandidates
    if "1" in agents:
        del agents["1"]
        agentsChosen.remove(1)
    elif len(agentsChosen) < 6:
        agentsChosen.append(1)
        agents["1"] = agentCandidates[0]
    else:
        _w1.Checkbutton1.deselect()
    number = "(" + str(len(agents)) + "/6)"
    _w1.agent_limit.set(number)
    return
def keep_agent2(*args):
    global agents, agentsChosen, agentCandidates
    if "2" in agents:
        del agents["2"]
        agentsChosen.remove(2)
    elif len(agentsChosen) < 6:
        agentsChosen.append(2)
        agents["2"] = agentCandidates[1]
    else:
        _w1.Checkbutton1_1.deselect()
    number = "(" + str(len(agents)) + "/6)"
    _w1.agent_limit.set(number)
    return
def keep_agent3(*args):
    global agents, agentsChosen, agentCandidates
    if "3" in agents:
        del agents["3"]
        agentsChosen.remove(3)
    elif len(agentsChosen) < 6:
        agentsChosen.append(3)
        agents["3"] = agentCandidates[2]
    else:
        _w1.Checkbutton1_1_1.deselect()
    number = "(" + str(len(agents)) + "/6)"
    _w1.agent_limit.set(number)
    return
def keep_agent4(*args):
    global agents, agentsChosen, agentCandidates
    if "4" in agents:
        del agents["4"]
        agentsChosen.remove(4)
    elif len(agentsChosen) < 6:
        agentsChosen.append(4)
        agents["4"] = agentCandidates[3]
    else:
        _w1.Checkbutton1_1_2.deselect()
    number = "(" + str(len(agents)) + "/6)"
    _w1.agent_limit.set(number)
    return
def keep_agent5(*args):
    global agents, agentsChosen, agentCandidates
    if "5" in agents:
        del agents["5"]
        agentsChosen.remove(5)
    elif len(agentsChosen) < 6:
        agentsChosen.append(5)
        agents["5"] = agentCandidates[4]
    else:
        _w1.Checkbutton1_1_3.deselect()
    number = "(" + str(len(agents)) + "/6)"
    _w1.agent_limit.set(number)
    return
def keep_agent6(*args):
    global agents, agentsChosen, agentCandidates
    if "6" in agents:
        del agents["6"]
        agentsChosen.remove(6)
    elif len(agentsChosen) < 6:
        agentsChosen.append(6)
        agents["6"] = agentCandidates[5]
    else:
        _w1.Checkbutton1_1_4.deselect()
    number = "(" + str(len(agents)) + "/6)"
    _w1.agent_limit.set(number)
    return
def keep_agent7(*args):
    global agents, agentsChosen, agentCandidates
    if "7" in agents:
        del agents["7"]
        agentsChosen.remove(7)
    elif len(agentsChosen) < 6:
        agentsChosen.append(7)
        agents["7"] = agentCandidates[6]
    else:
        _w1.Checkbutton1_1_5.deselect()
    number = "(" + str(len(agents)) + "/6)"
    _w1.agent_limit.set(number)
    return
def keep_agent8(*args):
    global agents, agentsChosen, agentCandidates
    if "8" in agents:
        del agents["8"]
        agentsChosen.remove(8)
    elif len(agentsChosen) < 6:
        agentsChosen.append(8)
        agents["8"] = agentCandidates[7]
    else:
        _w1.Checkbutton1_1_6.deselect()
    number = "(" + str(len(agents)) + "/6)"
    _w1.agent_limit.set(number)
    return
def keep_agent9(*args):
    global agents, agentsChosen, agentCandidates
    if "9" in agents:
        del agents["9"]
        agentsChosen.remove(9)
    elif len(agentsChosen) < 6:
        agentsChosen.append(9)
        agents["9"] = agentCandidates[8]
    else:
        _w1.Checkbutton1_1_7.deselect()
    number = "(" + str(len(agents)) + "/6)"
    _w1.agent_limit.set(number)
    return
def keep_agent10(*args):
    global agents, agentsChosen, agentCandidates
    if "10" in agents:
        del agents["10"]
        agentsChosen.remove(10)
    elif len(agentsChosen) < 6:
        agentsChosen.append(10)
        agents["10"] = agentCandidates[9]
    else:
        _w1.Checkbutton1_1_8.deselect()
    number = "(" + str(len(agents)) + "/6)"
    _w1.agent_limit.set(number)
    return

def generateAgents(amnt):
    global player, agents, agentsChosen
    theCandidates = []
    races = player.location.pops
    theRaces = races.copy()
    theRaces["Goblin"] = ((theRaces["Goblin"]+5)*10) + 50
    b = 0
    # using random number generation and the weights acquired through pops (with some extra advantages lended to Goblins)
    # in order to generate creatures of varying races in accordance with their regional commonality
    for i in theRaces:
        theRaces[i] += b
        b = theRaces[i]
        c = i
    for a in range(amnt):
        value = random.randint(1, theRaces[c])
        iteration = 1
        for o in theRaces:
            if iteration == 1 and theRaces[o] > value:
                keep = o
            elif iteration > 1 and theRaces[o] > value and theRaces[o] < theRaces[keep]:
                keep = o
            elif theRaces[o] == value:
                keep = o
                break
            else:
                iteration += -1
            iteration += 1
        # this variable is named after my emotions while debugging this thing
        ihateliving = cc.Reg()
        theirRace = ihateliving.make(keep)
        if theirRace.noble == False:
            theirRace.nickname = theirRace.firstName
        else:
            theirRace.nickname = theirRace.firstName + " " + theirRace.lastName
        theCandidates.append(theirRace)
    return theCandidates

def choose_team(*args):
    global player, agentCandidates, agents, agentsChosen
    agents = {}
    agentsChosen = []
    #generating agents based on the region chosen
    agentCandidates = generateAgents(10)
    #setting the information on the GUI
    fullName = agentCandidates[0].firstName + " " + agentCandidates[0].lastName
    _w1.agentName1.set(fullName)
    if agentCandidates[0].noble == True:
        _w1.agentRank1.set("Noble")
    else:
        _w1.agentRank1.set("Commoner")
    _w1.agentRace1.set(agentCandidates[0].race)
    _w1.classDets1.set(agentCandidates[0].giveClass())
    fullName = agentCandidates[1].firstName + " " + agentCandidates[1].lastName
    _w1.agentName2.set(fullName)
    if agentCandidates[1].noble == True:
        _w1.agentRank2.set("Noble")
    else:
        _w1.agentRank2.set("Commoner")
    _w1.agentRace2.set(agentCandidates[1].race)
    _w1.classDets2.set(agentCandidates[1].giveClass())
    fullName = agentCandidates[2].firstName + " " + agentCandidates[2].lastName
    _w1.agentName3.set(fullName)
    if agentCandidates[2].noble == True:
        _w1.agentRank3.set("Noble")
    else:
        _w1.agentRank3.set("Commoner")
    _w1.agentRace3.set(agentCandidates[2].race)
    _w1.classDets3.set(agentCandidates[2].giveClass())
    fullName = agentCandidates[3].firstName + " " + agentCandidates[3].lastName
    _w1.agentName4.set(fullName)
    if agentCandidates[3].noble == True:
        _w1.agentRank4.set("Noble")
    else:
        _w1.agentRank4.set("Commoner")
    _w1.agentRace4.set(agentCandidates[3].race)
    _w1.classDets4.set(agentCandidates[3].giveClass())
    fullName = agentCandidates[4].firstName + " " + agentCandidates[4].lastName
    _w1.agentName5.set(fullName)
    if agentCandidates[4].noble == True:
        _w1.agentRank5.set("Noble")
    else:
        _w1.agentRank5.set("Commoner")
    _w1.agentRace5.set(agentCandidates[4].race)
    _w1.classDets5.set(agentCandidates[4].giveClass())
    fullName = agentCandidates[5].firstName + " " + agentCandidates[5].lastName
    _w1.agentName6.set(fullName)
    if agentCandidates[5].noble == True:
        _w1.agentRank6.set("Noble")
    else:
        _w1.agentRank6.set("Commoner")
    _w1.agentRace6.set(agentCandidates[5].race)
    _w1.classDets6.set(agentCandidates[5].giveClass())
    fullName = agentCandidates[6].firstName + " " + agentCandidates[6].lastName
    _w1.agentName7.set(fullName)
    if agentCandidates[6].noble == True:
        _w1.agentRank7.set("Noble")
    else:
        _w1.agentRank7.set("Commoner")
    _w1.agentRace7.set(agentCandidates[6].race)
    _w1.classDets7.set(agentCandidates[6].giveClass())
    fullName = agentCandidates[7].firstName + " " + agentCandidates[7].lastName
    _w1.agentName8.set(fullName)
    if agentCandidates[7].noble == True:
        _w1.agentRank8.set("Noble")
    else:
        _w1.agentRank8.set("Commoner")
    _w1.agentRace8.set(agentCandidates[7].race)
    _w1.classDets8.set(agentCandidates[7].giveClass())
    fullName = agentCandidates[8].firstName + " " + agentCandidates[8].lastName
    _w1.agentName9.set(fullName)
    if agentCandidates[8].noble == True:
        _w1.agentRank9.set("Noble")
    else:
        _w1.agentRank9.set("Commoner")
    _w1.agentRace9.set(agentCandidates[8].race)
    _w1.classDets9.set(agentCandidates[8].giveClass())
    fullName = agentCandidates[9].firstName + " " + agentCandidates[9].lastName
    _w1.agentName10.set(fullName)
    if agentCandidates[9].noble == True:
        _w1.agentRank10.set("Noble")
    else:
        _w1.agentRank10.set("Commoner")
    _w1.agentRace10.set(agentCandidates[9].race)
    _w1.classDets10.set(agentCandidates[9].giveClass())
    raiseFrame(_w1.Team_chooser)
    return

def reroll_agents(*args):
    global agentsChosen, player, agentCandidates
    possibleAgents = generateAgents(10-len(agentsChosen))
    possibleNos = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    theDeletions = []
    for i in range(0, len(possibleNos)):
        if possibleNos[i] in agentsChosen:
            theDeletions.append(possibleNos[i])
    for e in theDeletions:
        if e in possibleNos:
            possibleNos.remove(e)
    iteration = -1
    for o in possibleNos:
        iteration += 1
        agentCandidates[o-1] = possibleAgents[iteration]
        match o:
            case 1:
                fullName = possibleAgents[iteration].firstName + " " + possibleAgents[iteration].lastName
                _w1.agentName1.set(fullName)
                if possibleAgents[iteration].noble == True:
                    _w1.agentRank1.set("Noble")
                else:
                    _w1.agentRank1.set("Commoner")
                _w1.agentRace1.set(possibleAgents[iteration].race)
                _w1.classDets1.set(possibleAgents[iteration].giveClass())
            case 2:
                fullName = possibleAgents[iteration].firstName + " " + possibleAgents[iteration].lastName
                _w1.agentName2.set(fullName)
                if possibleAgents[iteration].noble == True:
                    _w1.agentRank2.set("Noble")
                else:
                    _w1.agentRank2.set("Commoner")
                _w1.agentRace2.set(possibleAgents[iteration].race)
                _w1.classDets2.set(possibleAgents[iteration].giveClass())
            case 3:
                fullName = possibleAgents[iteration].firstName + " " + possibleAgents[iteration].lastName
                _w1.agentName3.set(fullName)
                if possibleAgents[iteration].noble == True:
                    _w1.agentRank3.set("Noble")
                else:
                    _w1.agentRank3.set("Commoner")
                _w1.agentRace3.set(possibleAgents[iteration].race)
                _w1.classDets3.set(possibleAgents[iteration].giveClass())
            case 4:
                fullName = possibleAgents[iteration].firstName + " " + possibleAgents[iteration].lastName
                _w1.agentName4.set(fullName)
                if possibleAgents[iteration].noble == True:
                    _w1.agentRank4.set("Noble")
                else:
                    _w1.agentRank4.set("Commoner")
                _w1.agentRace4.set(possibleAgents[iteration].race)
                _w1.classDets4.set(possibleAgents[iteration].giveClass())
            case 5:
                fullName = possibleAgents[iteration].firstName + " " + possibleAgents[iteration].lastName
                _w1.agentName5.set(fullName)
                if possibleAgents[iteration].noble == True:
                    _w1.agentRank5.set("Noble")
                else:
                    _w1.agentRank5.set("Commoner")
                _w1.agentRace5.set(possibleAgents[iteration].race)
                _w1.classDets5.set(possibleAgents[iteration].giveClass())
            case 6:
                fullName = possibleAgents[iteration].firstName + " " + possibleAgents[iteration].lastName
                _w1.agentName6.set(fullName)
                if possibleAgents[iteration].noble == True:
                    _w1.agentRank6.set("Noble")
                else:
                    _w1.agentRank6.set("Commoner")
                _w1.agentRace6.set(possibleAgents[iteration].race)
                _w1.classDets6.set(possibleAgents[iteration].giveClass())
            case 7:
                fullName = possibleAgents[iteration].firstName + " " + possibleAgents[iteration].lastName
                _w1.agentName7.set(fullName)
                if possibleAgents[iteration].noble == True:
                    _w1.agentRank7.set("Noble")
                else:
                    _w1.agentRank7.set("Commoner")
                _w1.agentRace7.set(possibleAgents[iteration].race)
                _w1.classDets7.set(possibleAgents[iteration].giveClass())
            case 8:
                fullName = possibleAgents[iteration].firstName + " " + possibleAgents[iteration].lastName
                _w1.agentName8.set(fullName)
                if possibleAgents[iteration].noble == True:
                    _w1.agentRank8.set("Noble")
                else:
                    _w1.agentRank8.set("Commoner")
                _w1.agentRace8.set(possibleAgents[iteration].race)
                _w1.classDets8.set(possibleAgents[iteration].giveClass())
            case 9:
                fullName = possibleAgents[iteration].firstName + " " + possibleAgents[iteration].lastName
                _w1.agentName9.set(fullName)
                if possibleAgents[iteration].noble == True:
                    _w1.agentRank9.set("Noble")
                else:
                    _w1.agentRank9.set("Commoner")
                _w1.agentRace9.set(possibleAgents[iteration].race)
                _w1.classDets9.set(possibleAgents[iteration].giveClass())
            case 10:
                fullName = possibleAgents[iteration].firstName + " " + possibleAgents[iteration].lastName
                _w1.agentName10.set(fullName)
                if possibleAgents[iteration].noble == True:
                    _w1.agentRank10.set("Noble")
                else:
                    _w1.agentRank10.set("Commoner")
                _w1.agentRace10.set(possibleAgents[iteration].race)
                _w1.classDets10.set(possibleAgents[iteration].giveClass())
    return

def editTarget(value):
    value = _w1.mission_type.get()
    _w1.target.set("")
    if value == "Assassination":
        nobles = player.location.nobles
        nicknames = []
        for i in nobles:
            nicknames.append(i.nickname)
        _w1.target['values'] = nicknames
    elif value == "Change Location":
        _w1.target['values'] = ["Byzend", "Gorkhen", "Ushnakh", "Elden", "Darkhour", "Hevok", "Media", "Graygold", "Highland", "Centria", "Hobbiton", "Dirennia", "Merwendel", "Faewind"]
    else:
        _w1.target["values"] = [""]
    return

def editRegion(region):
    region = _w1.region_selection.get()
    match region:
        case "The Elden Fields":
            region = "Elden"
        case "Highland Helm":
            region = "Highland"
    region = theGame.getRegion(region)
    _w1.Label5_2.configure(text = str(region.name))
    _w1.local_heat.configure(text = str(region.heat))
    _w1.local_stability.configure(text = str(region.stability))
    _w1.local_guard_level.configure(text = str(region.guards))
    value = 0
    for i in region.pops:
        value += region.pops[i]
    value = value*10000
    _w1.local_pops.configure(text = str(value))

def editEnemy (enemy):
    enemy = _w1.enemyList.get()
    for i in theEvent.lineup[2]:
        if i[0].nickname == enemy:
            _w1.enemy_health.configure(text = str(i[0].attr["health"]))
            _w1.enemy_agility.configure(text = str(i[0].attr["agility"]))
            _w1.enemy_ap.configure(text = str(i[0].attr["ap"]))
            _w1.enemy_armor.configure(text = str(i[0].attr["armor"]))
            theEvent.target = i
            if theEvent.status == "player":
                values = theEvent.plot(theEvent.player, theEvent.target)
                difficulty, minDam, maxDam = values[0], values[1], values[3]
                thePlot = theEvent.player[0].nickname + " will need to roll " + str(difficulty) + " or higher in order to deal " + str(minDam) + "-" + str(maxDam) + " damage"
                _w1.attackPlot.configure(text = thePlot)

def editAgent(agent):
    agent = _w1.Agent_list.get()
    for i in theGame.agents:
        if i.nickname == agent:
            _w1.field_agility.configure(text = str(i.attr["agility"]))
            _w1.field_health.configure(text = str(i.attr["health"])+"/"+str(i.attr["hmax"]))
            _w1.field_damage.configure(text = str(i.attr["damage"]))
            _w1.field_armor.configure(text = str(i.attr["armor"]))
            _w1.field_ap.configure(text = str(i.attr["ap"]))
            _w1.field_fight.configure(text = str(i.skills["fight"]))
            _w1.field_stealth.configure(text = str(i.skills["stealth"]))
            _w1.field_speech.configure(text = str(i.skills["speech"]))
            _w1.field_name.configure(text = i.nickname)
            _w1.field_sex.configure(text = i.sex)
            _w1.field_race.configure(text = i.race)
            _w1.field_kills.configure(text = str(len(i.history["kills"])))
            _w1.Weapon_list.set(i.equip["weapon"].name)
            weapons = []
            for e in theGame.itempool:
                if e.type == "weapon":
                    weapons.append(e.name)
            weapons.insert(0, "none")
            _w1.Weapon_list["values"] = weapons
            _w1.Armor_list.set(i.equip["armor"].name)
            armors = []
            for b in theGame.itempool:
                if b.type == "armor":
                    armors.append(b.name)
            armors.insert(0, "none")
            _w1.Armor_list["values"] = armors

def editArmor(armor):
    armor = _w1.Armor_list.get()
    agent = _w1.Agent_list.get()
    theGame.swapEquip(agent, armor, "armor")
    editAgent(True)
    return

def editWeapon(weapon):
    weapon = _w1.Weapon_list.get()
    agent = _w1.Agent_list.get()
    theGame.swapEquip(agent, weapon, "weapon")
    editAgent(True)
    return

def start_game(*args):
    theAgents = []
    for i in agents:
        theAgents.append(agents[i])
    theGame.starting_team(theAgents)
    _w1.region_selection.set(player.location.name)
    _w1.current_location.configure(text = player.location.name)
    editRegion(player.location)
    _w1.mission_type.bind('<<ComboboxSelected>>', editTarget)
    _w1.region_selection.bind('<<ComboboxSelected>>', editRegion)
    _w1.enemyList.bind('<<ComboboxSelected>>', editEnemy)
    _w1.Agent_list.bind('<<ComboboxSelected>>', editAgent)
    _w1.Armor_list.bind('<<ComboboxSelected>>', editArmor)
    _w1.Weapon_list.bind('<<ComboboxSelected>>', editWeapon)
    agentNames = []
    for i in theAgents:
        agentNames.append(i.nickname)
    _w1.Agent_list["values"] = agentNames
    _w1.Agent_list.set(agentNames[0])
    editAgent(agentNames[0])
    # _w1.mission_type.insert(END, "Assassination", "Recruitment", "Buy Equipment", "Change Location")
    # _w1.region_selection.insert(END, "Byzend", "Gorkhen", "Ushnakh", "Elden", "Hevok", "Darkhour", "Media", "Centria", "Graygold", "Highland", "Hobbiton", "Dirennia", "Merwendel", "Faewind")
    theGame.start_Game(player.location)
    _w1.total_funds.set(str(theGame.funds))
    _w1.total_heat.set(str(theGame.heat))
    _w1.total_stability.set(str(theGame.stability) + "%")
    _w1.turn_no.set(str(theGame.turn))
    raiseFrame(_w1.Main_game)

def back_to_location_picker(*args):
    _w1.choose_spot.tkraise()
    raiseFrame(_w1.Start_location)

def agent_skills(agentNo):
    global agentCandidates
    agent = agentCandidates[agentNo]
    thing = agent.noble
    if thing == False:
        _w1.Label6.configure(text=agent.firstName)
    else:
        fullName = agent.firstName + " " + agent.lastName
        _w1.agent_name = fullName
    _w1.agent_fight.set(agent.skills["fight"])
    _w1.agent_stealth.set(agent.skills["stealth"])
    _w1.agent_speech.set(agent.skills["speech"])
    _w1.agent_learning.set(agent.skills["learning"])
    _w1.agent_management.set(agent.skills["management"])
    _w1.Agent_skills.tkraise()

def close_game_check(*args):
    if _debug:
        print('gui_support.close_game_check')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

def okay_anyways():
    close_submenu()
    end_turn()

def end_turn(*args):
    global eventButtons, theEvent, eventLvl, theGame
    result = theGame.end_turn()
    if isinstance(result, (GameLoop.Events)):
        if isinstance(result, GameLoop.Pack_up):
            result.run()
            end_turn()
        else:
            theEvent = result
            choices = theEvent.run()
            eventLvl = 0
            _w1.event_message.configure(text = choices[0][0])
            for i in range(1, len(choices[0])):
                eventButtons[i-1].configure(text = choices[0][i])
            _w1.Event_screen.tkraise()
    elif result == "done":
        _w1.total_funds.set(str(theGame.funds))
        _w1.total_heat.set(str(theGame.heat))
        _w1.total_stability.set(str(theGame.stability) + "%")
        _w1.turn_no.set(str(theGame.turn))
        agentNames = []
        for i in theGame.agents:
            agentNames.append(i.nickname)
        _w1.Agent_list["values"] = agentNames
        _w1.Agent_list.set(agentNames[0])
        editAgent(agentNames[0])
    else:
        _w1.total_funds.set(str(theGame.funds))
        _w1.total_heat.set(str(theGame.heat))
        _w1.total_stability.set(str(theGame.stability) + "%")
        _w1.turn_no.set(str(theGame.turn))

def load_options(*args):
    if _debug:
        print('gui_support.load_options')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

def save_game(*args):
    if _debug:
        print('gui_support.save_game')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

def close_submenu(*args):
    global lastFrame
    lastFrame.tkraise()
    return

def attack(*args):
    theEvent.launch()
    return

def eventCommand(choice):
    global theEvent, eventLvl, eventButtons
    response = theEvent.run(eventLvl, choice)
    if response == "done":
        close_submenu()
        return end_turn()
    elif response == "fight":
        theEvent.fight()
    elif len(response[0]) == 1:
        _w1.event_message.configure(text = response[0][0])
    else:
        eventLvl = response[1]
        _w1.event_message.configure(text = response[0][0])
        for i in range(1, len(response[0])):
            eventButtons[i-1].configure(text = response[0][i])

def queue_mission(*args):
    global theGame
    theGame.queueEvent(_w1.mission_type.get(), _w1.target.get())


if __name__ == '__main__':
    gui.start_up()





